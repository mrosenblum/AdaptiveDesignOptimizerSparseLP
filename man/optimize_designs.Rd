% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/convert_input_step_1.R
\name{optimize_designs}
\alias{optimize_designs}
\title{Adaptive Enrichment Design Optimization Using Sparse Linear Programming
Authors: Michael Rosenblum, Ethan Fang, Han Liu}
\usage{
optimize_designs(ui.n.arms, ui.type.of.outcome.data,
  ui.time.to.event.trial.type,
  ui.time.to.event.non.inferiority.trial.margin, ui.subpopulation.1.size,
  ui.total.alpha, ui.max.size, ui.max.duration, ui.accrual.yearly.rate,
  ui.followup.length, ui.optimization.target,
  ui.time.to.event.censoring.rate, ui.mcid, ui.incorporate.precision.gain,
  ui.relative.efficiency, ui.max.stages, ui.include.designs.start.subpop.1,
  ui.population.parameters, ui.desired.power, ui.scenario.weights,
  min.n.per.arm = 25, min.enrollment.period = 0.5,
  simulated.annealing.parameter.function.scale = 1,
  simulated.annealing.parameter.n.scale = 100,
  simulated.annealing.parameter.period.scale = 2,
  simulated.annealing.parameter.max.iterations = 1000,
  simulated.annealing.parameter.n.simulations = 10000,
  simulated.annealing.parameter.means.temperature = 100,
  simulated.annealing.parameter.survival.temperature = 10,
  simulated.annealing.parameter.evals.per.temp = 10,
  simulated.annealing.parameter.report.iteration = 1,
  simulated.annealing.parameter.power.penalty = 1e+05)
}
\arguments{
\item{type.of.outcome.data}{"continuous", "binary"}

\item{subpopulation.1.size}{Proportion of overall population in subpopulation 1. Must be between 0 and 1.}

\item{total.alpha}{Familywise Type I error rate (1-sided)}

\item{accrual.yearly.rate}{Number of participants enrolled per year; assumed constant throughout trial}

\item{followup.length}{Time from enrollment to measurement of primary outcome (only used for continuous or binary outcome types)}

\item{population.parameters}{Matrix encoding scenarios (data generating distributions) used to define power constraints and  objective function; each row defines a data generating distribution; the columns represent subpopulation 1 outcome mean and variance followed by subpopulation 2 outcome mean and variance (4 entries total).}

\item{number.choices.end.of.stage.1}{Number of enrollment choices at end of stage 1}

\item{stage.1.sample.sizes}{Vector with 2 entries representing stage 1 sample sizes for subpopulations 1 and 2, respectively}

\item{stage.2.sample.sizes.per.enrollment.choice}{Matrix with number.choices.end.of.stage.1 rows and 2 columns, where the (i,j) entry represents the stage 2 sample size under enrollment choice i for subpopulation j.}

\item{objective.function.weights}{Vector with length equal to number of rows of population.parameters, representing weights used to define the objective function}

\item{power.constraints}{Matrix with same number of rows as population.parameters (each representing a data generating distribution) and three columns corresponding to the required power to reject (at least) H_01, H_02, H_0C, respectively.}

\item{type.of.LP.solver}{"matlab", "cplex", "GLPK" The linear program solve that you want to use; assumes that you have installed this already}
}
\value{
4 element list containing optimized designs from four classes (with increasing complexity):
}
\description{
Adaptive Enrichment Design Optimization Using Sparse Linear Programming
Authors: Michael Rosenblum, Ethan Fang, Han Liu
}
\section{Designs}{

Each optimized design is a list containing: design.parameters and design.performance
}

\section{design.parameters}{

design.parameters has the following elements:
}

\examples{
#For demonstration purposes, the examples below use a coarse discretization.
#Example 1: continuous outcome
input_vector <- convert_input_step_1(
  ui.n.arms=2,
  ui.type.of.outcome.data="continuous",
  ui.time.to.event.trial.type="",
  ui.time.to.event.non.inferiority.trial.margin=NULL,
  ui.subpopulation.1.size=0.5,
  ui.total.alpha=0.05,
  ui.max.size=1000,
  ui.max.duration=5,
  ui.accrual.yearly.rate=250,
  ui.followup.length=1,
  ui.optimization.target="size",
  ui.time.to.event.censoring.rate=0,
  ui.mcid=NULL,
  ui.incorporate.precision.gain=FALSE,
  ui.relative.efficiency=1,
  ui.max.stages=5,
  ui.include.designs.start.subpop.1=FALSE,
  ui.population.parameters=matrix(c(15,15,3600,3600,3600,3600,
                                    15,0,3600,3600,3600,3600,
                                    0,15,3600,3600,3600,3600,
                                    0,0,3600,3600,3600,3600),nrow=4, ncol=6, byrow=TRUE,dimnames=
    list(c(),c("delta1","delta2","sigma1_trt","sigma1_con","sigma2_trt","sigma2_con"))),
  ui.desired.power=matrix(c(0,0,0.8,
                            0.8,0,0,
                            0,0.8,0,
                            0,0,0), nrow=4, ncol=3, byrow=TRUE,
    dimnames=list(c(),c("Pow_H(0,1)","Pow_H(0,2)","Pow_H(0,C)"))),
  ui.scenario.weights=matrix(c(0.25,0.25,0.25,0.25),ncol=1,dimnames=list(c(),c("weight"))),
  simulated.annealing.parameter.max.iterations=2
)

#Example 2: binary outcome; 1 treatment arm versus control; superiority design
optimized_designs <- optimize_designs(
  ui.n.arms=2,
  ui.type.of.outcome.data="binary",
  ui.time.to.event.trial.type="",
  ui.time.to.event.non.inferiority.trial.margin=NULL,
  ui.subpopulation.1.size=0.4,
  ui.total.alpha=0.05,
  ui.max.size=2000,
  ui.max.duration=5,
  ui.accrual.yearly.rate=400,
  ui.followup.length=0,
  ui.optimization.target="size",
  ui.time.to.event.censoring.rate=0,
  ui.mcid=NULL,
  ui.incorporate.precision.gain=TRUE,
  ui.relative.efficiency=1.2,
  ui.max.stages=5,
  ui.include.designs.start.subpop.1=FALSE,
  ui.population.parameters=matrix(c(0.4,0.3,0.5,0.4,0.4,0.3,0.4,0.4,0.3,0.3,0.4,0.4),
    nrow=3, ncol=4, byrow=TRUE,dimnames=list(c(),c("p1_trt","p1_con","p2_trt","p2_con"))),
  ui.desired.power=matrix(c(0,0,0.8,0.8,0,0,0,0,0), nrow=3, ncol=3, byrow=TRUE,
    dimnames=list(c(),c("Pow_H(0,1)","Pow_H(0,2)","Pow_Reject_H0,1_and_H0,2"))),
  ui.scenario.weights=matrix(c(0.33,0.33,0.34),ncol=1,dimnames=list(c(),c("weight"))),
  simulated.annealing.parameter.max.iterations=2
)

 #Example 3: continuous outcome; 2 treatment arms versus control; superiority design
 optimized_designs <- optimize_designs(
   ui.n.arms=3,
   ui.type.of.outcome.data="continuous",
   ui.time.to.event.trial.type="",
   ui.time.to.event.non.inferiority.trial.margin=NULL,
   ui.subpopulation.1.size=0.49,
   ui.total.alpha=0.05,
   ui.max.size=3000,
   ui.max.duration=8,
   ui.accrual.yearly.rate=240,
   ui.followup.length=0.5,
   ui.optimization.target="size",
   ui.time.to.event.censoring.rate=0,
   ui.mcid=NULL,
   ui.incorporate.precision.gain=TRUE,
   ui.relative.efficiency=1,
   ui.max.stages=4,
   ui.include.designs.start.subpop.1=FALSE,
   ui.population.parameters=matrix(c(0,3600,0,3600,0,3600,0,3600,0,3600,0,3600,0,3600,0,3600,
   15,3600,0,3600,0,3600,0,3600,0,3600,0,3600,15,3600,0,3600,15,3600,0,3600,0,3600,0,3600,15,
   3600,15,3600,0,3600,0,3600,0,3600,0,3600,15,3600,15,3600,15,3600,0,3600,0,3600,0,3600,15,
   3600,15,3600,15,3600,15,3600), nrow=6, ncol=12, byrow=TRUE),
   ui.desired.power=matrix(c(
     0,0,0,0,0,
     0.8,0,0,0,0,
     0.8,0,0.8,0,0,
     0.8,0.8,0,0,0,
     0.8,0.8,0.8,0,0,
     0.8,0.8,0.8,0.8,0),
     nrow=6, ncol=5, byrow=TRUE),
   ui.scenario.weights=matrix(c(0.166,0.166,0.166,0.166,0.166,0.167)),
   simulated.annealing.parameter.max.iterations=2)
}
